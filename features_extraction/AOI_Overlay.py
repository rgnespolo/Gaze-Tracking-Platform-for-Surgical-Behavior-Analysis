import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.ticker as tick
import time
pd.options.mode.chained_assignment = None  # default='warn'
from scipy.signal import savgol_filter

n_surgeons = 11
overlap_threshold = 130
subspecialty = ['retina', 'cataract', 'other']
subspecialty_user = [1, 1, 1, 1, 3, 2]
phases = ['rhexis', 'phaco', 'cortex', 'core_vitr', 'memb_peel', 'laser']

#IDs of each group of surgeons
attendings = [1,2,9]
residents = [4,5,6]
fellows = [3,7,8,10,11]

pd.set_option("display.max_rows", None, "display.max_columns", None)
pd.options.display.width = None

df = pd.read_csv(r'all_experts_one_sheet.csv') #load gaze coordinates - Columns [frame,phase,user,x,y,prev_x,prev_y,dist]
df_tooltip = pd.read_csv(r'detections_vitrector.csv', usecols=['frame_tooltip','x_tooltip', 'y_tooltip']) #load detections generated by the deep learning model
fig,ax = plt.subplots()

overlap_all_users = []
mean_dist_all_users = []

def main():
    # We will be looping through all users - You can select the surgical phase by using the index value of the list "phases". In this example, surgical phase is core vitrectomy (4)
    # Specific group of surgeons and subspecialties can be selected by filtering according to the lists 'subspecialty_user', 'attendings', 'residents', and 'fellows'
    for i in range(n_surgeons):
        df_gaze = df.query('phase == [4] & user == ' + str(i+1))
        # add column to match the frame number from df_gaze with the frame number of the df_tooltip
        #optic disc will consider both 3 retina phases
        df_gaze.insert(loc=0, column='frame_gaze_per_user', value=np.arange(len(df_gaze)))
        #sync frame of gaze with frame of detection
        df_merged = df_gaze.set_index('frame_gaze_per_user').join(df_tooltip.set_index('frame_tooltip'))
        df_merged_notna = df_merged[df_merged['x_tooltip'].notna()]
        df_merged_notna['l2_dist_gaze_tooltip'] = df_merged_notna.apply(
            lambda row: (np.sqrt(((row.x-row.x_tooltip)**2 + (row.y-row.y_tooltip)**2))), axis=1)
        #Overlap with the AOI is identified when <130 (3 degrees of visualization with the setup used)
        df_merged_notna['is_overlap'] = df_merged_notna.apply(
            lambda row: (np.sqrt(((row.x-row.x_tooltip)**2 + (row.y-row.y_tooltip)**2)) < overlap_threshold), axis=1) #add condition for true or false ie < 130
        overlap = (df_merged_notna['is_overlap'].sum()/df_merged_notna['is_overlap'].count())
        print('user: ' + str(i+1) + ' Overlap with the tooltip: ' +
             str(overlap))
        overlap_all_users.append(overlap)
        mean_dist = (round(df_merged_notna['l2_dist_gaze_tooltip'].mean(),2))
        mean_dist_all_users.append(mean_dist)

        print('Surgeon ' + str(i+1) + ' Mean distance to the AOI: ' + str(mean_dist))
        print('Surgeon ' + str(i+1) + ' Total distance to the AOI: ' + str(round(df_merged_notna['l2_dist_gaze_tooltip'].sum(),2)))

        # #convert x-axis to seconds
        df_merged_notna['frame'] = df_merged_notna['frame'].div(60)

        #Savgol filter for improved visualization of gaze patterns
        w = savgol_filter(df_merged_notna.l2_dist_gaze_tooltip, 15, 2)
        ax.plot(df_merged_notna.frame, w, label='Surgeon '+ str(i+1))


    #std for overlap
    df_overlap = pd.DataFrame(overlap_all_users)
    #print([x - 1 for x in attendings])
    print(df_overlap[df_overlap.index.isin([x - 1 for x in attendings])].std())
    print(df_overlap[df_overlap.index.isin([x - 1 for x in residents])].std())
    print(df_overlap[df_overlap.index.isin([x - 1 for x in fellows])].std())

    #Std for mean dist (can be changed to .mean or .sum
    # df_mean_dist = pd.DataFrame(mean_dist_all_users)
    # #print([x - 1 for x in attendings])
    # print(df_mean_dist[df_mean_dist.index.isin([x - 1 for x in attendings])].mean())
    # print(df_mean_dist[df_mean_dist.index.isin([x - 1 for x in fellows])].mean())
    # print(df_mean_dist[df_mean_dist.index.isin([x - 1 for x in residents])].mean())



    plt.axhline(y=130, color='r', linestyle='-')
    plt.title('Distance to the selected AOI', fontsize = 22, fontweight = 'bold')
    formatter = tick.FuncFormatter(lambda ms, x: time.strftime('%M:%S', time.gmtime(ms)))
    ax.xaxis.set_major_formatter(formatter)
    lines = ax.get_lines()
    leg = ax.legend(fancybox=True, shadow=True)
    lined = {}  # Will map legend lines to original lines.
    for legline, origline in zip(leg.get_lines(), lines):
        legline.set_picker(True)  # Enable picking on the legend line.
        lined[legline] = origline
    def on_pick(event):
        # On the pick event, find the original line corresponding to the legend
        # proxy line, and toggle its visibility.
        legline = event.artist
        origline = lined[legline]
        visible = not origline.get_visible()
        origline.set_visible(visible)
        # Change the alpha on the line in the legend so we can see what lines
        # have been toggled.
        legline.set_alpha(1.0 if visible else 0.2)
        fig.canvas.draw()
    plt.rcParams.update({'font.size': 15})
    fig.canvas.mpl_connect('pick_event', on_pick)
    plt.xlabel('Time (mm:ss)', fontsize = 18)
    plt.ylabel('Distance to instrument tooltip (pixels)', fontsize = 18)
    plt.legend(loc='upper right')
    ax.tick_params(axis='x', labelsize=15)
    ax.tick_params(axis='y', labelsize=15)
    plt.show()


if __name__ == "__main__":
    main()

